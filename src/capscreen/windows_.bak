use log::error;
use std::{
    os::raw::c_void,
    sync::{Arc, Mutex},
};
use tao::{monitor::MonitorHandle, platform::windows::MonitorHandleExtWindows};
use windows_capture::{
    capture::{Context, GraphicsCaptureApiHandler},
    graphics_capture_api::{GraphicsCaptureApi, InternalCaptureControl},
    monitor::Monitor,
    settings::{
        ColorFormat, CursorCaptureSettings, DirtyRegionSettings, DrawBorderSettings,
        MinimumUpdateIntervalSettings, SecondaryWindowSettings, Settings,
    },
};

use crate::app::capscreen::{CaptureError, Frame};
struct SharedFrameCapture {
    data: Arc<Mutex<Option<Frame>>>,
    captured: bool,
}

impl GraphicsCaptureApiHandler for SharedFrameCapture {
    type Flags = Arc<Mutex<Option<Frame>>>;
    type Error = Box<dyn std::error::Error + Send + Sync>;

    fn new(ctx: Context<Self::Flags>) -> Result<Self, Self::Error> {
        Ok(Self {
            data: ctx.flags,
            captured: false,
        })
    }

    fn on_frame_arrived(
        &mut self,
        frame: &mut windows_capture::frame::Frame,
        capture_control: InternalCaptureControl,
    ) -> Result<(), Self::Error> {
        if !self.captured {
            let frame_buffer = frame.buffer()?;
            let width = frame_buffer.width();
            let height = frame_buffer.height();
            let color_format = frame_buffer.color_format();
            log::error!(
                "width: {}, height: {}, color_format: {:?}",
                width,
                height,
                color_format
            );

            let mut temp_buffer = Vec::new();
            let pixel_data = frame_buffer.as_nopadding_buffer(&mut temp_buffer);

            let frame_data = Frame {
                width,
                height,
                data: pixel_data.to_vec(),
            };

            *self.data.lock().unwrap() = Some(frame_data);
            self.captured = true;
            capture_control.stop();
        }
        Ok(())
    }
}

pub fn capscreen_windows(handle: &MonitorHandle) -> Result<Frame, CaptureError> {
    let h_monitor = handle.hmonitor();
    let monitor = Monitor::from_raw_hmonitor(h_monitor as *mut c_void);
    let capture_item: windows_capture::settings::GraphicsCaptureItemType =
        monitor.try_into().map_err(|e| {
            error!(
                "Failed to convert monitor to GraphicsCaptureItemType: {:?}",
                e
            );
            CaptureError::FailedToFindDisplay
        })?;
    let shared_data: Arc<Mutex<Option<Frame>>> = Arc::new(Mutex::new(None));
    let shared_data_clone = shared_data.clone();

    let draw_border_setting = match GraphicsCaptureApi::is_border_settings_supported() {
        Ok(true) => DrawBorderSettings::WithoutBorder,
        Ok(false) | Err(_) => {
            log::error!("Unsupported border settings, using default settings (may have flickering)");
            DrawBorderSettings::Default
        }
    };
    let cursor_capture_setting = match GraphicsCaptureApi::is_cursor_settings_supported() {
        Ok(true) => CursorCaptureSettings::WithoutCursor,
        Ok(false) | Err(_) => {
            log::error!("Unsupported cursor settings, using default settings (may have cursor)");
            CursorCaptureSettings::Default
        }
    };
    let settings = Settings::new(
        capture_item,
        cursor_capture_setting,
        draw_border_setting,
        SecondaryWindowSettings::Default,
        MinimumUpdateIntervalSettings::Default,
        DirtyRegionSettings::Default,
        ColorFormat::Rgba8,
        shared_data_clone, // 将共享数据作为 flags 传递
    );

    SharedFrameCapture::start(settings).map_err(|e| {
        error!("Failed to start SharedFrameCapture: {:?}", e);
        CaptureError::FailedToCaptureImage
    })?;
    let frame_data = shared_data.lock().unwrap().take().ok_or_else(|| {
        error!("Failed to take frame data");
        CaptureError::FailedToCaptureImage
    })?;

    Ok(frame_data)
}
